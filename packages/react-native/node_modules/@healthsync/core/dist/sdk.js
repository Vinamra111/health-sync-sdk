"use strict";
/**
 * HealthSync SDK - Main Entry Point
 *
 * Central coordination and configuration hub for the HealthSync SDK.
 * Provides unified access to multiple health data sources through plugins.
 *
 * @module sdk
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HealthSyncSDK = void 0;
const unified_data_1 = require("./models/unified-data");
const plugin_interface_1 = require("./plugins/plugin-interface");
const plugin_registry_1 = require("./plugins/plugin-registry");
const config_1 = require("./types/config");
const query_1 = require("./types/query");
const event_emitter_1 = require("./utils/event-emitter");
const data_normalizer_1 = require("./normalizer/data-normalizer");
const cache_manager_1 = require("./cache/cache-manager");
/**
 * Default console logger
 */
const defaultLogger = {
    debug: (message, ...args) => {
        console.debug(`[HealthSync DEBUG] ${message}`, ...args);
    },
    info: (message, ...args) => {
        console.info(`[HealthSync INFO] ${message}`, ...args);
    },
    warn: (message, ...args) => {
        console.warn(`[HealthSync WARN] ${message}`, ...args);
    },
    error: (message, error, ...args) => {
        console.error(`[HealthSync ERROR] ${message}`, error, ...args);
    },
};
/**
 * HealthSync SDK
 *
 * Main SDK class providing unified access to health data sources.
 * Manages plugins, connections, queries, and synchronization.
 *
 * @class HealthSyncSDK
 */
class HealthSyncSDK {
    /**
     * Private constructor (use static initialize method)
     *
     * @param {SDKConfig} config - SDK configuration
     * @private
     */
    constructor(config) {
        /** SDK configuration */
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Plugin registry */
        Object.defineProperty(this, "pluginRegistry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Event emitter */
        Object.defineProperty(this, "eventEmitter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Logger instance */
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Data normalizer */
        Object.defineProperty(this, "normalizer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Cache manager */
        Object.defineProperty(this, "cacheManager", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.config = {
            ...config_1.DEFAULT_SDK_CONFIG,
            ...config,
            cache: { ...config_1.DEFAULT_SDK_CONFIG.cache, ...config.cache },
            retry: { ...config_1.DEFAULT_SDK_CONFIG.retry, ...config.retry },
        };
        this.logger = config.logger ?? defaultLogger;
        this.pluginRegistry = new plugin_registry_1.PluginRegistry();
        this.eventEmitter = new event_emitter_1.EventEmitter();
        this.normalizer = new data_normalizer_1.DataNormalizer({
            validate: true,
            calculateQuality: true,
            strictValidation: false,
        });
        // Build cache manager configuration
        const cacheManagerConfig = {
            enabled: this.config.cache?.enabled ?? true,
            logger: this.logger,
        };
        if (this.config.cache?.defaultTTL !== undefined) {
            cacheManagerConfig.defaultTTL = this.config.cache.defaultTTL;
        }
        if (this.config.cache?.ttlByDataType !== undefined) {
            cacheManagerConfig.ttlByDataType = this.config.cache.ttlByDataType;
        }
        if (this.config.cache?.maxSize !== undefined) {
            // Convert MB to approximate entry count (assuming ~1KB per entry)
            cacheManagerConfig.maxMemoryEntries = this.config.cache.maxSize * 1024;
        }
        this.cacheManager = new cache_manager_1.CacheManager(cacheManagerConfig);
    }
    /**
     * Initialize the SDK
     *
     * Creates a singleton instance of the SDK with the provided configuration.
     * If an instance already exists, it will be disposed and a new one created.
     *
     * @param {SDKConfig} config - SDK configuration
     * @returns {Promise<HealthSyncSDK>} Initialized SDK instance
     * @throws {ConfigurationError} If configuration is invalid
     */
    static async initialize(config) {
        // Dispose existing instance if present
        if (HealthSyncSDK.instance) {
            await HealthSyncSDK.instance.dispose();
        }
        const sdk = new HealthSyncSDK(config);
        await sdk.init();
        HealthSyncSDK.instance = sdk;
        return sdk;
    }
    /**
     * Get the current SDK instance
     *
     * @returns {HealthSyncSDK | null} SDK instance or null if not initialized
     */
    static getInstance() {
        return HealthSyncSDK.instance;
    }
    /**
     * Internal initialization
     *
     * @returns {Promise<void>}
     * @private
     */
    async init() {
        this.log(config_1.LogLevel.INFO, 'Initializing HealthSync SDK...');
        // Register provided plugins
        if (this.config.plugins && this.config.plugins.length > 0) {
            for (const plugin of this.config.plugins) {
                this.registerPlugin(plugin);
            }
        }
        this.log(config_1.LogLevel.INFO, 'HealthSync SDK initialized successfully');
        // Emit initialized event
        await this.emitEvent(query_1.SDKEvent.INITIALIZED, {
            event: query_1.SDKEvent.INITIALIZED,
            timestamp: new Date().toISOString(),
            data: { pluginCount: this.pluginRegistry.count() },
        });
    }
    // ============================================================================
    // Plugin Management
    // ============================================================================
    /**
     * Register a plugin
     *
     * @param {IHealthDataPlugin} plugin - Plugin to register
     * @returns {void}
     * @throws {PluginError} If plugin is invalid or already registered
     */
    registerPlugin(plugin) {
        this.log(config_1.LogLevel.INFO, `Registering plugin: ${plugin.name} (${plugin.id})`);
        this.pluginRegistry.register(plugin);
        // Emit plugin registered event
        this.emitEvent(query_1.SDKEvent.PLUGIN_REGISTERED, {
            event: query_1.SDKEvent.PLUGIN_REGISTERED,
            timestamp: new Date().toISOString(),
            data: { pluginId: plugin.id, pluginName: plugin.name },
        }).catch((error) => {
            this.log(config_1.LogLevel.ERROR, 'Error emitting plugin registered event', error);
        });
    }
    /**
     * Unregister a plugin
     *
     * @param {string} pluginId - ID of the plugin to unregister
     * @returns {Promise<void>}
     * @throws {PluginError} If plugin is not found
     */
    async unregisterPlugin(pluginId) {
        this.log(config_1.LogLevel.INFO, `Unregistering plugin: ${pluginId}`);
        await this.pluginRegistry.unregister(pluginId);
        // Emit plugin removed event
        await this.emitEvent(query_1.SDKEvent.PLUGIN_REMOVED, {
            event: query_1.SDKEvent.PLUGIN_REMOVED,
            timestamp: new Date().toISOString(),
            data: { pluginId },
        });
    }
    /**
     * Get available plugins
     *
     * @returns {Promise<PluginInfo[]>} Array of plugin information
     */
    async getAvailablePlugins() {
        return this.pluginRegistry.getPluginInfo();
    }
    /**
     * Get active (connected) plugins
     *
     * @returns {IHealthDataPlugin[]} Array of connected plugins
     */
    getActivePlugins() {
        return this.pluginRegistry.getConnectedPlugins();
    }
    // ============================================================================
    // Connection Management
    // ============================================================================
    /**
     * Connect to a health data source
     *
     * @param {HealthSource} source - Health source to connect to
     * @returns {Promise<ConnectionResult>} Connection result
     * @throws {ConnectionError} If connection fails
     */
    async connect(source) {
        this.log(config_1.LogLevel.INFO, `Connecting to ${source}...`);
        const plugin = this.pluginRegistry.getPluginBySource(source);
        if (!plugin) {
            throw new config_1.ConnectionError(`No plugin registered for source: ${source}`, source, 404);
        }
        try {
            // Initialize plugin if not already initialized
            if (!this.pluginRegistry.isInitialized(plugin.id)) {
                this.log(config_1.LogLevel.DEBUG, `Initializing plugin ${plugin.id}...`);
                await plugin.initialize({});
                this.pluginRegistry.markInitialized(plugin.id);
            }
            // Update status to connecting
            this.pluginRegistry.updateConnectionStatus(plugin.id, plugin_interface_1.ConnectionStatus.CONNECTING);
            // Attempt connection
            const result = await plugin.connect();
            // Update status based on result
            const newStatus = result.success ? plugin_interface_1.ConnectionStatus.CONNECTED : plugin_interface_1.ConnectionStatus.ERROR;
            this.pluginRegistry.updateConnectionStatus(plugin.id, newStatus);
            if (result.success) {
                this.log(config_1.LogLevel.INFO, `Successfully connected to ${source}`);
                // Emit connected event
                await this.emitEvent(query_1.SDKEvent.CONNECTED, {
                    event: query_1.SDKEvent.CONNECTED,
                    timestamp: new Date().toISOString(),
                    data: { source, pluginId: plugin.id, result },
                });
            }
            else {
                this.log(config_1.LogLevel.WARN, `Failed to connect to ${source}: ${result.message}`);
            }
            return result;
        }
        catch (error) {
            this.pluginRegistry.updateConnectionStatus(plugin.id, plugin_interface_1.ConnectionStatus.ERROR);
            this.log(config_1.LogLevel.ERROR, `Error connecting to ${source}`, error);
            throw new config_1.ConnectionError(`Failed to connect to ${source}: ${error.message}`, source, 500, { originalError: error });
        }
    }
    /**
     * Disconnect from a health data source
     *
     * @param {HealthSource} source - Health source to disconnect from
     * @returns {Promise<void>}
     * @throws {ConnectionError} If disconnection fails
     */
    async disconnect(source) {
        this.log(config_1.LogLevel.INFO, `Disconnecting from ${source}...`);
        const plugin = this.pluginRegistry.getPluginBySource(source);
        if (!plugin) {
            throw new config_1.ConnectionError(`No plugin registered for source: ${source}`, source, 404);
        }
        try {
            this.pluginRegistry.updateConnectionStatus(plugin.id, plugin_interface_1.ConnectionStatus.DISCONNECTING);
            await plugin.disconnect();
            this.pluginRegistry.updateConnectionStatus(plugin.id, plugin_interface_1.ConnectionStatus.DISCONNECTED);
            this.log(config_1.LogLevel.INFO, `Successfully disconnected from ${source}`);
            // Emit disconnected event
            await this.emitEvent(query_1.SDKEvent.DISCONNECTED, {
                event: query_1.SDKEvent.DISCONNECTED,
                timestamp: new Date().toISOString(),
                data: { source, pluginId: plugin.id },
            });
        }
        catch (error) {
            this.log(config_1.LogLevel.ERROR, `Error disconnecting from ${source}`, error);
            throw new config_1.ConnectionError(`Failed to disconnect from ${source}: ${error.message}`, source, 500, { originalError: error });
        }
    }
    /**
     * Get connection status for a health source
     *
     * @param {HealthSource} source - Health source
     * @returns {ConnectionStatus} Connection status
     */
    getConnectionStatus(source) {
        const plugin = this.pluginRegistry.getPluginBySource(source);
        if (!plugin) {
            return plugin_interface_1.ConnectionStatus.DISCONNECTED;
        }
        return this.pluginRegistry.getConnectionStatus(plugin.id);
    }
    // ============================================================================
    // Data Operations
    // ============================================================================
    /**
     * Query health data
     *
     * @param {HealthDataQuery} request - Query request
     * @returns {Promise<HealthDataResponse>} Query response with data
     * @throws {DataFetchError} If query fails
     */
    async query(request) {
        const startTime = Date.now();
        this.log(config_1.LogLevel.INFO, `Querying ${request.dataType} from ${request.startDate} to ${request.endDate}`);
        const sources = request.sources ?? this.getActivePlugins().map((p) => this.getSourceForPlugin(p));
        const allData = [];
        const errors = [];
        const sourcesQueried = [];
        const sourcesWithData = [];
        const sourcesFailed = [];
        let fromCache = false;
        for (const source of sources) {
            if (source === unified_data_1.HealthSource.UNKNOWN) {
                continue;
            }
            sourcesQueried.push(source);
            try {
                const plugin = this.pluginRegistry.getPluginBySource(source);
                if (!plugin) {
                    this.log(config_1.LogLevel.WARN, `No plugin for source: ${source}`);
                    continue;
                }
                // Check if plugin is connected
                const status = this.pluginRegistry.getConnectionStatus(plugin.id);
                if (status !== plugin_interface_1.ConnectionStatus.CONNECTED) {
                    this.log(config_1.LogLevel.WARN, `Plugin ${plugin.id} is not connected`);
                    sourcesFailed.push(source);
                    continue;
                }
                // Check cache first
                const cacheKey = {
                    source,
                    dataType: request.dataType,
                    startDate: request.startDate,
                    endDate: request.endDate,
                    params: {
                        limit: request.limit,
                        offset: request.offset,
                        sortOrder: request.sortOrder,
                    },
                };
                const cachedData = await this.cacheManager.get(cacheKey);
                if (cachedData && cachedData.length > 0) {
                    this.log(config_1.LogLevel.DEBUG, `Using cached data for ${source}`);
                    sourcesWithData.push(source);
                    allData.push(...cachedData);
                    fromCache = true;
                    continue;
                }
                // Build plugin query
                const pluginQuery = {
                    dataType: request.dataType,
                    startDate: request.startDate,
                    endDate: request.endDate,
                };
                if (request.limit !== undefined) {
                    pluginQuery.limit = request.limit;
                }
                if (request.offset !== undefined) {
                    pluginQuery.offset = request.offset;
                }
                if (request.sortOrder !== undefined) {
                    pluginQuery.sortOrder = request.sortOrder;
                }
                // Fetch raw data
                const rawData = await plugin.fetchData(pluginQuery);
                // Normalize data
                const normalizationResult = this.normalizer.normalize(rawData);
                if (normalizationResult.data.length > 0) {
                    sourcesWithData.push(source);
                    allData.push(...normalizationResult.data);
                    // Cache the normalized data
                    await this.cacheManager.set(cacheKey, normalizationResult.data);
                }
                // Log normalization warnings
                if (normalizationResult.warnings.length > 0) {
                    this.log(config_1.LogLevel.WARN, `Normalization warnings for ${source}: ${normalizationResult.warnings.join(', ')}`);
                }
            }
            catch (error) {
                this.log(config_1.LogLevel.ERROR, `Error querying ${source}`, error);
                sourcesFailed.push(source);
                errors.push(new config_1.SyncError(`Failed to query ${source}: ${error.message}`, 'fetch', source, request.dataType));
            }
        }
        const duration = Date.now() - startTime;
        const response = {
            success: allData.length > 0 || errors.length === 0,
            data: allData,
            totalCount: allData.length,
            count: allData.length,
            metadata: {
                executedAt: new Date().toISOString(),
                duration,
                fromCache,
                sourcesQueried,
                sourcesWithData,
            },
        };
        if (sourcesFailed.length > 0) {
            response.metadata.sourcesFailed = sourcesFailed;
        }
        if (errors.length > 0) {
            response.errors = errors;
        }
        return response;
    }
    /**
     * Sync health data
     *
     * @param {SyncOptions} [options] - Sync options
     * @returns {Promise<SyncResult>} Sync result
     */
    async sync(options) {
        const opts = { ...config_1.DEFAULT_SYNC_OPTIONS, ...options };
        const startTime = Date.now();
        const startedAt = new Date().toISOString();
        this.log(config_1.LogLevel.INFO, 'Starting data sync...');
        // Emit sync started event
        await this.emitEvent(query_1.SDKEvent.SYNC_STARTED, {
            event: query_1.SDKEvent.SYNC_STARTED,
            timestamp: startedAt,
            data: { options: opts },
        });
        const sources = opts.sources ?? this.getActivePlugins().map((p) => this.getSourceForPlugin(p));
        const dataTypes = opts.dataTypes ?? this.config.defaultDataTypes ?? [];
        const sourceResults = [];
        let totalRecords = 0;
        let newRecords = 0;
        let updatedRecords = 0;
        let failedRecords = 0;
        const errors = [];
        for (const source of sources) {
            if (source === unified_data_1.HealthSource.UNKNOWN) {
                continue;
            }
            const dataTypeResults = [];
            let sourceRecordCount = 0;
            let sourceSuccess = true;
            for (const dataType of dataTypes) {
                try {
                    const query = {
                        dataType,
                        startDate: opts.startDate ?? new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
                        endDate: opts.endDate ?? new Date().toISOString(),
                        sources: [source],
                    };
                    const response = await this.query(query);
                    const recordCount = response.data.length;
                    dataTypeResults.push({
                        dataType,
                        success: true,
                        recordCount,
                    });
                    sourceRecordCount += recordCount;
                    totalRecords += recordCount;
                    newRecords += recordCount; // TODO: Differentiate new vs updated
                }
                catch (error) {
                    sourceSuccess = false;
                    failedRecords++;
                    dataTypeResults.push({
                        dataType,
                        success: false,
                        recordCount: 0,
                        error: error,
                    });
                    errors.push(new config_1.SyncError(`Sync failed for ${source} - ${dataType}`, 'fetch', source, dataType));
                }
            }
            sourceResults.push({
                source,
                success: sourceSuccess,
                recordCount: sourceRecordCount,
                dataTypeResults,
            });
        }
        const completedAt = new Date().toISOString();
        const duration = Date.now() - startTime;
        const result = {
            success: errors.length === 0,
            totalRecords,
            newRecords,
            updatedRecords,
            failedRecords,
            startedAt,
            completedAt,
            duration,
            sourceResults,
        };
        if (errors.length > 0) {
            result.errors = errors;
        }
        this.log(config_1.LogLevel.INFO, `Sync completed: ${totalRecords} records in ${duration}ms`);
        // Emit sync completed event
        await this.emitEvent(query_1.SDKEvent.SYNC_COMPLETED, {
            event: query_1.SDKEvent.SYNC_COMPLETED,
            timestamp: completedAt,
            data: { result },
        });
        // Call completion callback if provided
        if (opts.onComplete) {
            opts.onComplete(result);
        }
        return result;
    }
    /**
     * Subscribe to data updates
     *
     * @param {DataUpdateCallback} callback - Callback function for data updates
     * @returns {EventSubscription} Subscription object
     */
    subscribe(callback) {
        return this.eventEmitter.on(query_1.SDKEvent.DATA_UPDATE, (eventData) => {
            if (eventData.data && Array.isArray(eventData.data)) {
                callback(eventData.data);
            }
        });
    }
    /**
     * Subscribe to SDK events
     *
     * @param {SDKEvent} event - Event to subscribe to
     * @param {(data: SDKEventData) => void} callback - Callback function
     * @returns {EventSubscription} Subscription object
     */
    on(event, callback) {
        return this.eventEmitter.on(event, callback);
    }
    // ============================================================================
    // Lifecycle
    // ============================================================================
    /**
     * Dispose the SDK
     *
     * Cleans up all resources, disconnects plugins, and clears state.
     *
     * @returns {Promise<void>}
     */
    async dispose() {
        this.log(config_1.LogLevel.INFO, 'Disposing HealthSync SDK...');
        // Clear event listeners
        this.eventEmitter.clear();
        // Dispose cache manager
        await this.cacheManager.dispose();
        // Dispose all plugins
        await this.pluginRegistry.clear();
        if (HealthSyncSDK.instance === this) {
            HealthSyncSDK.instance = null;
        }
        this.log(config_1.LogLevel.INFO, 'HealthSync SDK disposed');
    }
    // ============================================================================
    // Helper Methods
    // ============================================================================
    /**
     * Log a message
     *
     * @param {LogLevel} level - Log level
     * @param {string} message - Message to log
     * @param {Error} [error] - Optional error object
     * @private
     */
    log(level, message, error) {
        if (this.shouldLog(level)) {
            switch (level) {
                case config_1.LogLevel.DEBUG:
                    this.logger.debug(message);
                    break;
                case config_1.LogLevel.INFO:
                    this.logger.info(message);
                    break;
                case config_1.LogLevel.WARN:
                    this.logger.warn(message);
                    break;
                case config_1.LogLevel.ERROR:
                    this.logger.error(message, error);
                    break;
            }
        }
    }
    /**
     * Check if a log level should be logged
     *
     * @param {LogLevel} level - Log level to check
     * @returns {boolean} True if should log
     * @private
     */
    shouldLog(level) {
        const levels = [config_1.LogLevel.NONE, config_1.LogLevel.ERROR, config_1.LogLevel.WARN, config_1.LogLevel.INFO, config_1.LogLevel.DEBUG];
        const configLevelIndex = levels.indexOf(this.config.logLevel ?? config_1.LogLevel.WARN);
        const messageLevelIndex = levels.indexOf(level);
        return messageLevelIndex <= configLevelIndex;
    }
    /**
     * Emit an SDK event
     *
     * @param {SDKEvent} event - Event type
     * @param {SDKEventData} data - Event data
     * @returns {Promise<void>}
     * @private
     */
    async emitEvent(event, data) {
        await this.eventEmitter.emit(event, data);
    }
    /**
     * Get health source for a plugin
     *
     * @param {IHealthDataPlugin} plugin - Plugin
     * @returns {HealthSource} Health source
     * @private
     */
    getSourceForPlugin(plugin) {
        // Map plugin ID to health source
        const mapping = {
            'health-connect': unified_data_1.HealthSource.HEALTH_CONNECT,
            'health_connect': unified_data_1.HealthSource.HEALTH_CONNECT,
            'apple-health': unified_data_1.HealthSource.APPLE_HEALTH,
            'apple_health': unified_data_1.HealthSource.APPLE_HEALTH,
            healthkit: unified_data_1.HealthSource.APPLE_HEALTH,
            fitbit: unified_data_1.HealthSource.FITBIT,
            garmin: unified_data_1.HealthSource.GARMIN,
            oura: unified_data_1.HealthSource.OURA,
            whoop: unified_data_1.HealthSource.WHOOP,
            strava: unified_data_1.HealthSource.STRAVA,
            myfitnesspal: unified_data_1.HealthSource.MYFITNESSPAL,
        };
        return mapping[plugin.id.toLowerCase()] ?? unified_data_1.HealthSource.UNKNOWN;
    }
}
exports.HealthSyncSDK = HealthSyncSDK;
/** Singleton instance */
Object.defineProperty(HealthSyncSDK, "instance", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: null
});
//# sourceMappingURL=sdk.js.map