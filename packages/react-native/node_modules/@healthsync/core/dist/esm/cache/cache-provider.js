/**
 * Cache Provider Interface
 *
 * Abstract interface for cache storage backends.
 * Implementations can use different storage mechanisms (memory, SQLite, IndexedDB, etc.)
 *
 * @module cache/cache-provider
 */
/**
 * Generate cache key from CacheKey structure
 *
 * @param {CacheKey} key - Cache key structure
 * @returns {string} Serialized cache key
 */
export function generateCacheKey(key) {
    const base = `${key.source}:${key.dataType}:${key.startDate}:${key.endDate}`;
    if (!key.params || Object.keys(key.params).length === 0) {
        return base;
    }
    // Sort params for consistent key generation
    const sortedParams = Object.keys(key.params)
        .sort()
        .map(k => `${k}=${JSON.stringify(key.params[k])}`)
        .join('&');
    return `${base}?${sortedParams}`;
}
/**
 * Parse cache key string back to CacheKey structure
 *
 * @param {string} keyString - Serialized cache key
 * @returns {CacheKey | null} Parsed cache key or null if invalid
 */
export function parseCacheKey(keyString) {
    try {
        const parts = keyString.split('?');
        const basePart = parts[0];
        const paramsPart = parts[1];
        if (!basePart) {
            return null;
        }
        const [source, dataType, startDate, endDate] = basePart.split(':');
        if (!source || !dataType || !startDate || !endDate) {
            return null;
        }
        const key = {
            source: source,
            dataType: dataType,
            startDate,
            endDate,
        };
        if (paramsPart) {
            const params = {};
            paramsPart.split('&').forEach(pair => {
                const [k, v] = pair.split('=');
                if (k && v) {
                    params[k] = JSON.parse(v);
                }
            });
            key.params = params;
        }
        return key;
    }
    catch {
        return null;
    }
}
//# sourceMappingURL=cache-provider.js.map