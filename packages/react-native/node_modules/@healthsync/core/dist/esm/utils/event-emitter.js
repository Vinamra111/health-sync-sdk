/**
 * Event Emitter
 *
 * Simple event emitter implementation for SDK event subscriptions.
 * Zero dependencies, type-safe event handling.
 *
 * @module utils/event-emitter
 */
/**
 * Event Emitter
 *
 * Provides type-safe event emission and subscription.
 *
 * @class EventEmitter
 * @template TEvents - Map of event names to event data types
 */
export class EventEmitter {
    constructor() {
        /** Map of event names to listeners */
        Object.defineProperty(this, "listeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        /** Subscription counter for unique IDs */
        Object.defineProperty(this, "subscriptionCounter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /** Map of subscription IDs to unsubscribe functions */
        Object.defineProperty(this, "subscriptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    /**
     * Subscribe to an event
     *
     * @template K - Event name type
     * @param {K} event - Event name
     * @param {EventListener<TEvents[K]>} listener - Event listener function
     * @returns {EventSubscription} Subscription object
     */
    on(event, listener) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        const listeners = this.listeners.get(event);
        if (listeners) {
            listeners.add(listener);
        }
        // Generate unique subscription ID
        const subscriptionId = `sub_${++this.subscriptionCounter}_${String(event)}`;
        // Create unsubscribe function
        const unsubscribe = () => {
            this.off(event, listener);
            this.subscriptions.delete(subscriptionId);
        };
        this.subscriptions.set(subscriptionId, unsubscribe);
        return {
            id: subscriptionId,
            unsubscribe,
            isActive: () => this.subscriptions.has(subscriptionId),
        };
    }
    /**
     * Subscribe to an event (alias for `on`)
     *
     * @template K - Event name type
     * @param {K} event - Event name
     * @param {EventListener<TEvents[K]>} listener - Event listener function
     * @returns {EventSubscription} Subscription object
     */
    subscribe(event, listener) {
        return this.on(event, listener);
    }
    /**
     * Unsubscribe from an event
     *
     * @template K - Event name type
     * @param {K} event - Event name
     * @param {EventListener<TEvents[K]>} listener - Event listener function to remove
     * @returns {void}
     */
    off(event, listener) {
        const listeners = this.listeners.get(event);
        if (listeners) {
            listeners.delete(listener);
            // Clean up empty listener sets
            if (listeners.size === 0) {
                this.listeners.delete(event);
            }
        }
    }
    /**
     * Subscribe to an event once (automatically unsubscribes after first emission)
     *
     * @template K - Event name type
     * @param {K} event - Event name
     * @param {EventListener<TEvents[K]>} listener - Event listener function
     * @returns {EventSubscription} Subscription object
     */
    once(event, listener) {
        const wrappedListener = async (data) => {
            subscription.unsubscribe();
            const result = listener(data);
            if (result instanceof Promise) {
                await result;
            }
        };
        const subscription = this.on(event, wrappedListener);
        return subscription;
    }
    /**
     * Emit an event
     *
     * Calls all listeners registered for the event with the provided data.
     * Errors in listeners are caught and logged but do not stop other listeners.
     *
     * @template K - Event name type
     * @param {K} event - Event name
     * @param {TEvents[K]} data - Event data
     * @returns {Promise<void>}
     */
    async emit(event, data) {
        const listeners = this.listeners.get(event);
        if (!listeners || listeners.size === 0) {
            return;
        }
        // Call all listeners
        const promises = Array.from(listeners).map(async (listener) => {
            try {
                const result = listener(data);
                if (result instanceof Promise) {
                    await result;
                }
            }
            catch (error) {
                // Log error but don't stop other listeners
                console.error(`Error in event listener for '${String(event)}':`, error);
            }
        });
        await Promise.all(promises);
    }
    /**
     * Emit an event synchronously (does not wait for promises)
     *
     * @template K - Event name type
     * @param {K} event - Event name
     * @param {TEvents[K]} data - Event data
     * @returns {void}
     */
    emitSync(event, data) {
        const listeners = this.listeners.get(event);
        if (!listeners || listeners.size === 0) {
            return;
        }
        // Call all listeners without awaiting
        listeners.forEach((listener) => {
            try {
                listener(data);
            }
            catch (error) {
                console.error(`Error in event listener for '${String(event)}':`, error);
            }
        });
    }
    /**
     * Remove all listeners for a specific event
     *
     * @template K - Event name type
     * @param {K} event - Event name
     * @returns {void}
     */
    removeAllListeners(event) {
        // Remove subscriptions
        const listeners = this.listeners.get(event);
        if (listeners) {
            this.subscriptions.forEach((_unsubscribe, id) => {
                if (id.endsWith(`_${String(event)}`)) {
                    this.subscriptions.delete(id);
                }
            });
        }
        this.listeners.delete(event);
    }
    /**
     * Remove all listeners for all events
     *
     * @returns {void}
     */
    clear() {
        this.listeners.clear();
        this.subscriptions.clear();
    }
    /**
     * Get the number of listeners for an event
     *
     * @template K - Event name type
     * @param {K} event - Event name
     * @returns {number} Number of listeners
     */
    listenerCount(event) {
        return this.listeners.get(event)?.size ?? 0;
    }
    /**
     * Get all event names that have listeners
     *
     * @returns {Array<keyof TEvents>} Array of event names
     */
    eventNames() {
        return Array.from(this.listeners.keys());
    }
    /**
     * Check if there are any listeners for an event
     *
     * @template K - Event name type
     * @param {K} event - Event name
     * @returns {boolean} True if there are listeners
     */
    hasListeners(event) {
        return this.listenerCount(event) > 0;
    }
}
//# sourceMappingURL=event-emitter.js.map