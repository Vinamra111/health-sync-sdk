/**
 * Data Normalizer
 *
 * Main class for transforming platform-specific health data into unified models.
 * Handles validation, quality scoring, unit conversion, and data transformation.
 *
 * @module normalizer/data-normalizer
 */
import { DataType, DataQuality, HeartRateContext, ActivityType, } from '../models/unified-data';
import { UnitConverter } from './unit-converter';
import { DataValidator } from './validator';
import { QualityScorer } from './quality-scorer';
import { ValidationError } from '../types/config';
/**
 * Default normalization options
 */
const DEFAULT_OPTIONS = {
    validate: true,
    calculateQuality: true,
    strictValidation: false,
    minQuality: DataQuality.LOW,
    generateId: () => `health_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
};
/**
 * Data Normalizer
 *
 * Transforms raw platform-specific data into unified health data models.
 *
 * @class DataNormalizer
 */
export class DataNormalizer {
    /**
     * Create a new DataNormalizer
     *
     * @param {NormalizationOptions} [options] - Normalization options
     */
    constructor(options) {
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.options = { ...DEFAULT_OPTIONS, ...options };
    }
    /**
     * Normalize raw health data
     *
     * @param {RawHealthData[]} rawData - Raw data from plugin
     * @returns {NormalizationResult} Normalization result
     */
    normalize(rawData) {
        const normalized = [];
        const warnings = [];
        const failed = [];
        for (const raw of rawData) {
            try {
                const data = this.normalizeOne(raw);
                // Apply quality threshold
                if (this.options.calculateQuality && this.options.minQuality) {
                    const qualityScore = data.metadata.quality;
                    if (!QualityScorer.meetsThreshold({ quality: qualityScore }, this.options.minQuality)) {
                        warnings.push(`Data quality below threshold for ${raw.sourceId ?? 'unknown'}`);
                        continue;
                    }
                }
                normalized.push(data);
            }
            catch (error) {
                const errorMessage = error.message;
                warnings.push(errorMessage);
                failed.push({ raw, errors: [errorMessage] });
                if (this.options.strictValidation) {
                    throw error;
                }
            }
        }
        return {
            data: normalized,
            warnings,
            failed,
            stats: {
                total: rawData.length,
                normalized: normalized.length,
                failed: failed.length,
                warnings: warnings.length,
            },
        };
    }
    /**
     * Normalize a single raw data item
     *
     * @param {RawHealthData} raw - Raw data item
     * @returns {AnyHealthData} Normalized data
     * @private
     */
    normalizeOne(raw) {
        // Determine data type from source data type or infer
        const dataType = this.inferDataType(raw);
        // Create base metadata
        const metadata = this.createMetadata(raw, dataType);
        // Create base unified data
        const base = {
            id: this.options.generateId(),
            source: raw.source,
            dataType,
            timestamp: raw.timestamp,
            metadata,
        };
        if (raw.endTimestamp !== undefined) {
            base.endTimestamp = raw.endTimestamp;
        }
        // Normalize based on data type
        switch (dataType) {
            case DataType.STEPS:
                return this.normalizeSteps(raw, base);
            case DataType.HEART_RATE:
            case DataType.RESTING_HEART_RATE:
                return this.normalizeHeartRate(raw, base);
            case DataType.SLEEP:
                return this.normalizeSleep(raw, base);
            case DataType.ACTIVITY:
                return this.normalizeActivity(raw, base);
            case DataType.CALORIES:
                return this.normalizeCalories(raw, base);
            case DataType.DISTANCE:
                return this.normalizeDistance(raw, base);
            case DataType.BLOOD_OXYGEN:
                return this.normalizeBloodOxygen(raw, base);
            case DataType.BLOOD_PRESSURE:
                return this.normalizeBloodPressure(raw, base);
            case DataType.WEIGHT:
                return this.normalizeWeight(raw, base);
            case DataType.HEART_RATE_VARIABILITY:
                return this.normalizeHeartRateVariability(raw, base);
            case DataType.VO2_MAX:
                return this.normalizeVO2Max(raw, base);
            default:
                // Return base data for unsupported types
                return base;
        }
    }
    /**
     * Infer data type from raw data
     *
     * @param {RawHealthData} raw - Raw data
     * @returns {DataType} Inferred data type
     * @private
     */
    inferDataType(raw) {
        const sourceType = raw.sourceDataType.toLowerCase();
        // Map common source type names to DataType
        if (sourceType.includes('step')) {
            return DataType.STEPS;
        }
        if (sourceType.includes('heart') && sourceType.includes('rate')) {
            return DataType.HEART_RATE;
        }
        if (sourceType.includes('sleep')) {
            return DataType.SLEEP;
        }
        if (sourceType.includes('activity') || sourceType.includes('workout')) {
            return DataType.ACTIVITY;
        }
        if (sourceType.includes('calorie')) {
            return DataType.CALORIES;
        }
        if (sourceType.includes('distance')) {
            return DataType.DISTANCE;
        }
        if (sourceType.includes('oxygen') || sourceType.includes('spo2')) {
            return DataType.BLOOD_OXYGEN;
        }
        if (sourceType.includes('blood') && sourceType.includes('pressure')) {
            return DataType.BLOOD_PRESSURE;
        }
        if (sourceType.includes('weight')) {
            return DataType.WEIGHT;
        }
        if (sourceType.includes('hrv')) {
            return DataType.HEART_RATE_VARIABILITY;
        }
        if (sourceType.includes('vo2')) {
            return DataType.VO2_MAX;
        }
        // Default fallback - use raw.raw.type if available
        if (raw.raw['type']) {
            return raw.raw['type'];
        }
        throw new ValidationError(`Unable to infer data type from source type: ${raw.sourceDataType}`, ['sourceDataType']);
    }
    /**
     * Create metadata for normalized data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {DataType} dataType - Data type
     * @returns {DataMetadata} Metadata
     * @private
     */
    createMetadata(raw, dataType) {
        const device = raw.raw['device'] ?? undefined;
        const manufacturer = raw.raw['manufacturer'] ?? undefined;
        const model = raw.raw['model'] ?? undefined;
        const platform = raw.raw['platform'] ?? undefined;
        const isManualEntry = raw.raw['isManual'] ?? false;
        const recordedAt = raw.timestamp;
        const syncedAt = new Date().toISOString();
        let quality = DataQuality.MEDIUM;
        if (this.options.calculateQuality) {
            const qualityScore = QualityScorer.calculateQualityScore({
                source: raw.source,
                dataType,
                manufacturer,
                model,
                isManualEntry,
                recordedAt: new Date(recordedAt),
                syncedAt: new Date(syncedAt),
                completeness: 1.0,
            });
            quality = qualityScore.quality;
        }
        const metadata = {
            quality,
            isManualEntry,
            recordedAt,
            syncedAt,
        };
        if (device !== undefined) {
            metadata.device = device;
        }
        if (manufacturer !== undefined) {
            metadata.manufacturer = manufacturer;
        }
        if (model !== undefined) {
            metadata.model = model;
        }
        if (platform !== undefined) {
            metadata.platform = platform;
        }
        if (raw.sourceId !== undefined) {
            metadata.sourceId = raw.sourceId;
        }
        const customMetadata = raw.raw['metadata'];
        if (customMetadata !== undefined) {
            metadata.custom = customMetadata;
        }
        return metadata;
    }
    // ============================================================================
    // Data Type Normalizers
    // ============================================================================
    /**
     * Normalize steps data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {UnifiedHealthData} base - Base unified data
     * @returns {StepsData} Normalized steps data
     * @private
     */
    normalizeSteps(raw, base) {
        const count = Number(raw.raw['count'] ?? raw.raw['steps'] ?? 0);
        const distance = raw.raw['distance'] ? Number(raw.raw['distance']) : undefined;
        if (this.options.validate) {
            const validation = DataValidator.validateSteps(count);
            if (!validation.valid) {
                throw new ValidationError(`Invalid steps data: ${validation.errors.join(', ')}`, ['count']);
            }
        }
        const result = {
            ...base,
            dataType: DataType.STEPS,
            count,
        };
        if (distance !== undefined) {
            result.distance = distance;
        }
        return result;
    }
    /**
     * Normalize heart rate data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {UnifiedHealthData} base - Base unified data
     * @returns {HeartRateData} Normalized heart rate data
     * @private
     */
    normalizeHeartRate(raw, base) {
        const bpm = Number(raw.raw['bpm'] ?? raw.raw['heartRate'] ?? 0);
        const context = raw.raw['context'] ?? HeartRateContext.GENERAL;
        const minBpm = raw.raw['minBpm'] ? Number(raw.raw['minBpm']) : undefined;
        const maxBpm = raw.raw['maxBpm'] ? Number(raw.raw['maxBpm']) : undefined;
        if (this.options.validate) {
            const validation = DataValidator.validateHeartRate(bpm);
            if (!validation.valid) {
                throw new ValidationError(`Invalid heart rate data: ${validation.errors.join(', ')}`, ['bpm']);
            }
        }
        const result = {
            ...base,
            dataType: DataType.HEART_RATE,
            bpm,
            context,
        };
        if (minBpm !== undefined) {
            result.minBpm = minBpm;
        }
        if (maxBpm !== undefined) {
            result.maxBpm = maxBpm;
        }
        return result;
    }
    /**
     * Normalize sleep data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {UnifiedHealthData} base - Base unified data
     * @returns {SleepData} Normalized sleep data
     * @private
     */
    normalizeSleep(raw, base) {
        const stages = raw.raw['stages'] ?? [];
        const totalDuration = Number(raw.raw['totalDuration'] ?? 0);
        const efficiency = Number(raw.raw['efficiency'] ?? 100);
        if (this.options.validate) {
            const validation = DataValidator.validateSleepDuration(totalDuration);
            const efficiencyValidation = DataValidator.validateSleepEfficiency(efficiency);
            if (!validation.valid) {
                throw new ValidationError(`Invalid sleep duration: ${validation.errors.join(', ')}`, ['totalDuration']);
            }
            if (!efficiencyValidation.valid) {
                throw new ValidationError(`Invalid sleep efficiency: ${efficiencyValidation.errors.join(', ')}`, ['efficiency']);
            }
        }
        const result = {
            ...base,
            dataType: DataType.SLEEP,
            stages,
            totalDuration,
            efficiency,
        };
        if (raw.raw['timeInBed']) {
            result.timeInBed = Number(raw.raw['timeInBed']);
        }
        if (raw.raw['timeToFallAsleep']) {
            result.timeToFallAsleep = Number(raw.raw['timeToFallAsleep']);
        }
        if (raw.raw['awakeDuration']) {
            result.awakeDuration = Number(raw.raw['awakeDuration']);
        }
        if (raw.raw['lightSleepDuration']) {
            result.lightSleepDuration = Number(raw.raw['lightSleepDuration']);
        }
        if (raw.raw['deepSleepDuration']) {
            result.deepSleepDuration = Number(raw.raw['deepSleepDuration']);
        }
        if (raw.raw['remSleepDuration']) {
            result.remSleepDuration = Number(raw.raw['remSleepDuration']);
        }
        return result;
    }
    /**
     * Normalize activity data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {UnifiedHealthData} base - Base unified data
     * @returns {ActivityData} Normalized activity data
     * @private
     */
    normalizeActivity(raw, base) {
        const activityType = raw.raw['activityType'] ?? ActivityType.OTHER;
        const duration = Number(raw.raw['duration'] ?? 0);
        const result = {
            ...base,
            dataType: DataType.ACTIVITY,
            activityType,
            duration,
        };
        if (raw.raw['calories']) {
            result.calories = Number(raw.raw['calories']);
        }
        if (raw.raw['distance']) {
            result.distance = Number(raw.raw['distance']);
        }
        if (raw.raw['averageHeartRate']) {
            result.averageHeartRate = Number(raw.raw['averageHeartRate']);
        }
        if (raw.raw['peakHeartRate']) {
            result.peakHeartRate = Number(raw.raw['peakHeartRate']);
        }
        if (raw.raw['averagePace']) {
            result.averagePace = Number(raw.raw['averagePace']);
        }
        if (raw.raw['elevationGain']) {
            result.elevationGain = Number(raw.raw['elevationGain']);
        }
        if (raw.raw['metrics']) {
            result.metrics = raw.raw['metrics'];
        }
        return result;
    }
    /**
     * Normalize calories data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {UnifiedHealthData} base - Base unified data
     * @returns {CaloriesData} Normalized calories data
     * @private
     */
    normalizeCalories(raw, base) {
        const total = Number(raw.raw['total'] ?? raw.raw['calories'] ?? 0);
        if (this.options.validate) {
            const validation = DataValidator.validateCalories(total);
            if (!validation.valid) {
                throw new ValidationError(`Invalid calories data: ${validation.errors.join(', ')}`, ['total']);
            }
        }
        const result = {
            ...base,
            dataType: DataType.CALORIES,
            total,
        };
        if (raw.raw['active']) {
            result.active = Number(raw.raw['active']);
        }
        if (raw.raw['bmr']) {
            result.bmr = Number(raw.raw['bmr']);
        }
        return result;
    }
    /**
     * Normalize distance data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {UnifiedHealthData} base - Base unified data
     * @returns {DistanceData} Normalized distance data
     * @private
     */
    normalizeDistance(raw, base) {
        let meters = Number(raw.raw['meters'] ?? raw.raw['distance'] ?? 0);
        // Convert if in different unit
        const unit = raw.raw['unit'];
        if (unit === 'km' || unit === 'kilometers') {
            meters = UnitConverter.kmToMeters(meters);
        }
        else if (unit === 'miles') {
            meters = UnitConverter.milesToMeters(meters);
        }
        if (this.options.validate) {
            const validation = DataValidator.validateDistance(meters);
            if (!validation.valid) {
                throw new ValidationError(`Invalid distance data: ${validation.errors.join(', ')}`, ['meters']);
            }
        }
        const result = {
            ...base,
            dataType: DataType.DISTANCE,
            meters,
        };
        const measurementSource = raw.raw['source'];
        if (measurementSource !== undefined) {
            result.measurementSource = measurementSource;
        }
        return result;
    }
    /**
     * Normalize blood oxygen data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {UnifiedHealthData} base - Base unified data
     * @returns {BloodOxygenData} Normalized blood oxygen data
     * @private
     */
    normalizeBloodOxygen(raw, base) {
        const percentage = Number(raw.raw['percentage'] ?? raw.raw['spo2'] ?? 0);
        if (this.options.validate) {
            const validation = DataValidator.validateBloodOxygen(percentage);
            if (!validation.valid) {
                throw new ValidationError(`Invalid blood oxygen data: ${validation.errors.join(', ')}`, ['percentage']);
            }
        }
        const result = {
            ...base,
            dataType: DataType.BLOOD_OXYGEN,
            percentage,
        };
        const method = raw.raw['method'];
        if (method !== undefined) {
            result.method = method;
        }
        return result;
    }
    /**
     * Normalize blood pressure data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {UnifiedHealthData} base - Base unified data
     * @returns {BloodPressureData} Normalized blood pressure data
     * @private
     */
    normalizeBloodPressure(raw, base) {
        const systolic = Number(raw.raw['systolic'] ?? 0);
        const diastolic = Number(raw.raw['diastolic'] ?? 0);
        if (this.options.validate) {
            const validation = DataValidator.validateBloodPressure(systolic, diastolic);
            if (!validation.valid) {
                throw new ValidationError(`Invalid blood pressure data: ${validation.errors.join(', ')}`, ['systolic', 'diastolic']);
            }
        }
        const result = {
            ...base,
            dataType: DataType.BLOOD_PRESSURE,
            systolic,
            diastolic,
        };
        const pulsePressure = systolic - diastolic;
        if (pulsePressure !== undefined) {
            result.pulsePressure = pulsePressure;
        }
        const position = raw.raw['position'];
        if (position !== undefined) {
            result.position = position;
        }
        return result;
    }
    /**
     * Normalize weight data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {UnifiedHealthData} base - Base unified data
     * @returns {WeightData} Normalized weight data
     * @private
     */
    normalizeWeight(raw, base) {
        let kilograms = Number(raw.raw['kilograms'] ?? raw.raw['weight'] ?? 0);
        // Convert if in different unit
        const unit = raw.raw['unit'];
        if (unit === 'lbs' || unit === 'pounds') {
            kilograms = UnitConverter.poundsToKg(kilograms);
        }
        if (this.options.validate) {
            const validation = DataValidator.validateWeight(kilograms);
            if (!validation.valid) {
                throw new ValidationError(`Invalid weight data: ${validation.errors.join(', ')}`, ['kilograms']);
            }
        }
        const result = {
            ...base,
            dataType: DataType.WEIGHT,
            kilograms,
        };
        // Always include pounds conversion for convenience
        const pounds = UnitConverter.kgToPounds(kilograms);
        if (pounds !== undefined) {
            result.pounds = pounds;
        }
        return result;
    }
    /**
     * Normalize heart rate variability data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {UnifiedHealthData} base - Base unified data
     * @returns {HeartRateVariabilityData} Normalized HRV data
     * @private
     */
    normalizeHeartRateVariability(raw, base) {
        const milliseconds = Number(raw.raw['milliseconds'] ?? raw.raw['hrv'] ?? 0);
        const result = {
            ...base,
            dataType: DataType.HEART_RATE_VARIABILITY,
            milliseconds,
        };
        const method = raw.raw['method'] ?? 'SDNN';
        if (method !== undefined) {
            result.method = method;
        }
        return result;
    }
    /**
     * Normalize VO2 Max data
     *
     * @param {RawHealthData} raw - Raw data
     * @param {UnifiedHealthData} base - Base unified data
     * @returns {VO2MaxData} Normalized VO2 Max data
     * @private
     */
    normalizeVO2Max(raw, base) {
        const value = Number(raw.raw['value'] ?? raw.raw['vo2max'] ?? 0);
        const result = {
            ...base,
            dataType: DataType.VO2_MAX,
            value,
        };
        const method = raw.raw['method'];
        if (method !== undefined) {
            result.method = method;
        }
        return result;
    }
}
//# sourceMappingURL=data-normalizer.js.map