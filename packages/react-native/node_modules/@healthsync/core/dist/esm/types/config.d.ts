/**
 * Configuration Types
 *
 * This module defines all configuration interfaces and types for the HealthSync SDK,
 * including SDK initialization config, sync options, and error types.
 *
 * @module types/config
 */
import { DataType, HealthSource } from '../models/unified-data';
import { IHealthDataPlugin } from '../plugins/plugin-interface';
/**
 * Log level enumeration
 *
 * @enum {string}
 */
export declare enum LogLevel {
    /** No logging */
    NONE = "none",
    /** Log errors only */
    ERROR = "error",
    /** Log warnings and errors */
    WARN = "warn",
    /** Log info, warnings, and errors */
    INFO = "info",
    /** Log everything including debug messages */
    DEBUG = "debug"
}
/**
 * Cache storage layer
 *
 * @enum {string}
 */
export declare enum CacheLayer {
    /** In-memory cache (fastest, session-only) */
    MEMORY = "memory",
    /** Local database cache (SQLite, IndexedDB) */
    LOCAL_DB = "local_db",
    /** Cloud storage cache (user's backend) */
    CLOUD = "cloud",
    /** All cache layers */
    ALL = "all"
}
/**
 * Cache configuration options
 *
 * @interface CacheConfig
 */
export interface CacheConfig {
    /** Enable caching */
    enabled: boolean;
    /** Which cache layers to use */
    layers: CacheLayer[];
    /** Default cache duration in milliseconds */
    defaultTTL: number;
    /** Maximum cache size in MB */
    maxSize?: number;
    /** Custom TTL per data type (in milliseconds) */
    ttlByDataType?: Partial<Record<DataType, number>>;
    /** Whether to use LRU eviction for memory cache */
    useLRU?: boolean;
    /** Cloud cache endpoint (if using cloud layer) */
    cloudEndpoint?: string;
    /** Cloud cache authentication */
    cloudAuth?: {
        apiKey?: string;
        token?: string;
        headers?: Record<string, string>;
    };
}
/**
 * Retry strategy configuration
 *
 * @interface RetryConfig
 */
export interface RetryConfig {
    /** Maximum number of retry attempts */
    maxAttempts: number;
    /** Initial delay in milliseconds */
    initialDelay: number;
    /** Maximum delay in milliseconds */
    maxDelay: number;
    /** Backoff multiplier (2 = exponential doubling) */
    backoffMultiplier: number;
    /** Whether to add random jitter to delays */
    useJitter: boolean;
    /** Timeout for each attempt in milliseconds */
    timeout: number;
}
/**
 * Main SDK configuration
 *
 * @interface SDKConfig
 */
export interface SDKConfig {
    /** Base URL for backend API (optional) */
    apiBaseUrl?: string;
    /** Client application identifier */
    clientId?: string;
    /** Client application secret (for server-side apps) */
    clientSecret?: string;
    /** Environment (development, staging, production) */
    environment?: 'development' | 'staging' | 'production';
    /** Cache configuration */
    cache?: Partial<CacheConfig>;
    /** Retry configuration */
    retry?: Partial<RetryConfig>;
    /** Log level for SDK operations */
    logLevel?: LogLevel;
    /** Custom logger implementation */
    logger?: Logger;
    /** Plugins to register on initialization */
    plugins?: IHealthDataPlugin[];
    /** Default data types to sync */
    defaultDataTypes?: DataType[];
    /** Whether to sync data automatically on initialization */
    autoSync?: boolean;
    /** Interval for background sync in milliseconds (0 = disabled) */
    syncInterval?: number;
    /** Maximum age of data to fetch in days */
    maxDataAge?: number;
    /** Whether to enable real-time updates */
    enableRealtimeUpdates?: boolean;
    /** Custom user identifier */
    userId?: string;
    /** Additional custom configuration */
    custom?: Record<string, unknown>;
}
/**
 * Logger interface for custom logging implementations
 *
 * @interface Logger
 */
export interface Logger {
    /** Log debug message */
    debug(message: string, ...args: unknown[]): void;
    /** Log info message */
    info(message: string, ...args: unknown[]): void;
    /** Log warning message */
    warn(message: string, ...args: unknown[]): void;
    /** Log error message */
    error(message: string, error?: Error, ...args: unknown[]): void;
}
/**
 * Sync options for data synchronization
 *
 * @interface SyncOptions
 */
export interface SyncOptions {
    /** Health sources to sync from (if not specified, sync all connected sources) */
    sources?: HealthSource[];
    /** Data types to sync (if not specified, sync all supported types) */
    dataTypes?: DataType[];
    /** Start date for data sync (ISO 8601 format) */
    startDate?: string;
    /** End date for data sync (ISO 8601 format) */
    endDate?: string;
    /** Whether to force a full sync (ignore cache) */
    forceFull?: boolean;
    /** Whether to sync in the background */
    background?: boolean;
    /** Callback for sync progress updates */
    onProgress?: SyncProgressCallback;
    /** Callback when sync completes */
    onComplete?: SyncCompleteCallback;
    /** Callback when sync fails */
    onError?: SyncErrorCallback;
    /** Maximum concurrent sync operations */
    maxConcurrency?: number;
    /** Priority level (higher = sync first) */
    priority?: number;
}
/**
 * Sync progress information
 *
 * @interface SyncProgress
 */
export interface SyncProgress {
    /** Current source being synced */
    currentSource: HealthSource;
    /** Current data type being synced */
    currentDataType: DataType;
    /** Total number of sources to sync */
    totalSources: number;
    /** Number of sources completed */
    completedSources: number;
    /** Total number of data types to sync */
    totalDataTypes: number;
    /** Number of data types completed */
    completedDataTypes: number;
    /** Total records synced so far */
    totalRecords: number;
    /** Overall progress percentage (0-100) */
    percentage: number;
    /** Estimated time remaining in milliseconds */
    estimatedTimeRemaining?: number;
}
/**
 * Sync result information
 *
 * @interface SyncResult
 */
export interface SyncResult {
    /** Whether the sync was successful */
    success: boolean;
    /** Total number of records synced */
    totalRecords: number;
    /** Number of new records added */
    newRecords: number;
    /** Number of records updated */
    updatedRecords: number;
    /** Number of records that failed to sync */
    failedRecords: number;
    /** Sync start timestamp (ISO 8601) */
    startedAt: string;
    /** Sync completion timestamp (ISO 8601) */
    completedAt: string;
    /** Total duration in milliseconds */
    duration: number;
    /** Results per source */
    sourceResults: SourceSyncResult[];
    /** Errors encountered during sync */
    errors?: SyncError[];
}
/**
 * Sync result for a specific source
 *
 * @interface SourceSyncResult
 */
export interface SourceSyncResult {
    /** Health source */
    source: HealthSource;
    /** Whether this source sync succeeded */
    success: boolean;
    /** Number of records synced from this source */
    recordCount: number;
    /** Results per data type */
    dataTypeResults: DataTypeSyncResult[];
    /** Error if sync failed */
    error?: Error;
}
/**
 * Sync result for a specific data type
 *
 * @interface DataTypeSyncResult
 */
export interface DataTypeSyncResult {
    /** Data type */
    dataType: DataType;
    /** Whether this data type sync succeeded */
    success: boolean;
    /** Number of records synced for this type */
    recordCount: number;
    /** Error if sync failed */
    error?: Error;
}
/**
 * Sync progress callback
 *
 * @callback SyncProgressCallback
 * @param {SyncProgress} progress - Current sync progress
 * @returns {void}
 */
export type SyncProgressCallback = (progress: SyncProgress) => void;
/**
 * Sync complete callback
 *
 * @callback SyncCompleteCallback
 * @param {SyncResult} result - Sync result
 * @returns {void}
 */
export type SyncCompleteCallback = (result: SyncResult) => void;
/**
 * Sync error callback
 *
 * @callback SyncErrorCallback
 * @param {SyncError} error - Sync error
 * @returns {void}
 */
export type SyncErrorCallback = (error: SyncError) => void;
/**
 * Base error class for all SDK errors
 *
 * @class SDKError
 * @extends {Error}
 */
export declare class SDKError extends Error {
    /** Error code */
    readonly code: string;
    /** HTTP status code (if applicable) */
    readonly statusCode?: number;
    /** Additional error details */
    readonly details?: Record<string, unknown>;
    /** Original error (if wrapped) */
    readonly originalError?: Error;
    constructor(message: string, code: string, statusCode?: number, details?: Record<string, unknown>, originalError?: Error);
}
/**
 * Configuration error
 *
 * @class ConfigurationError
 * @extends {SDKError}
 */
export declare class ConfigurationError extends SDKError {
    constructor(message: string, details?: Record<string, unknown>);
}
/**
 * Authentication error
 *
 * @class AuthenticationError
 * @extends {SDKError}
 */
export declare class AuthenticationError extends SDKError {
    constructor(message: string, statusCode?: number, details?: Record<string, unknown>);
}
/**
 * Connection error
 *
 * @class ConnectionError
 * @extends {SDKError}
 */
export declare class ConnectionError extends SDKError {
    /** Source that failed to connect */
    readonly source: HealthSource;
    constructor(message: string, source: HealthSource, statusCode?: number, details?: Record<string, unknown>);
}
/**
 * Data fetch error
 *
 * @class DataFetchError
 * @extends {SDKError}
 */
export declare class DataFetchError extends SDKError {
    /** Source where fetch failed */
    readonly source: HealthSource;
    /** Data type that failed to fetch */
    readonly dataType: DataType;
    constructor(message: string, source: HealthSource, dataType: DataType, statusCode?: number, details?: Record<string, unknown>);
}
/**
 * Rate limit error
 *
 * @class RateLimitError
 * @extends {SDKError}
 */
export declare class RateLimitError extends SDKError {
    /** Timestamp when rate limit resets (ISO 8601) */
    readonly resetAt: string;
    /** Retry after duration in seconds */
    readonly retryAfter: number;
    constructor(message: string, resetAt: string, retryAfter: number);
}
/**
 * Validation error
 *
 * @class ValidationError
 * @extends {SDKError}
 */
export declare class ValidationError extends SDKError {
    /** Fields that failed validation */
    readonly fields: string[];
    constructor(message: string, fields: string[], details?: Record<string, unknown>);
}
/**
 * Plugin error
 *
 * @class PluginError
 * @extends {SDKError}
 */
export declare class PluginError extends SDKError {
    /** Plugin ID where error occurred */
    readonly pluginId: string;
    constructor(message: string, pluginId: string, statusCode?: number, details?: Record<string, unknown>);
}
/**
 * Cache error
 *
 * @class CacheError
 * @extends {SDKError}
 */
export declare class CacheError extends SDKError {
    /** Cache layer where error occurred */
    readonly layer: CacheLayer;
    constructor(message: string, layer: CacheLayer, details?: Record<string, unknown>);
}
/**
 * Sync error
 *
 * @class SyncError
 * @extends {SDKError}
 */
export declare class SyncError extends SDKError {
    /** Source where sync failed */
    readonly source?: HealthSource;
    /** Data type where sync failed */
    readonly dataType?: DataType;
    /** Phase where sync failed */
    readonly phase: 'connection' | 'fetch' | 'normalize' | 'cache' | 'unknown';
    constructor(message: string, phase: 'connection' | 'fetch' | 'normalize' | 'cache' | 'unknown', source?: HealthSource, dataType?: DataType, details?: Record<string, unknown>);
}
/**
 * Network error
 *
 * @class NetworkError
 * @extends {SDKError}
 */
export declare class NetworkError extends SDKError {
    /** Whether the error is retryable */
    readonly isRetryable: boolean;
    constructor(message: string, statusCode?: number, isRetryable?: boolean, details?: Record<string, unknown>);
}
/**
 * Default SDK configuration values
 */
export declare const DEFAULT_SDK_CONFIG: Required<Omit<SDKConfig, 'apiBaseUrl' | 'clientId' | 'clientSecret' | 'logger' | 'userId' | 'custom'>>;
/**
 * Default sync options
 */
export declare const DEFAULT_SYNC_OPTIONS: Partial<SyncOptions>;
//# sourceMappingURL=config.d.ts.map