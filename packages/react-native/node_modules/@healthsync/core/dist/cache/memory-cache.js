"use strict";
/**
 * In-Memory Cache Provider
 *
 * Fast, session-only cache using LRU eviction strategy.
 * Implements the ICacheProvider interface with in-memory Map storage.
 *
 * @module cache/memory-cache
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryCacheProvider = void 0;
const cache_provider_1 = require("./cache-provider");
/**
 * In-Memory Cache Provider with LRU Eviction
 *
 * @class MemoryCacheProvider
 * @implements {ICacheProvider}
 */
class MemoryCacheProvider {
    /**
     * Create memory cache provider
     *
     * @param {number} [maxSize=1000] - Maximum number of entries
     */
    constructor(maxSize = 1000) {
        Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "head", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "tail", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "hits", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "misses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "evictions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        this.maxSize = maxSize;
    }
    /**
     * Get cached data by key
     *
     * @param {string} key - Cache key
     * @returns {Promise<CacheEntry | null>} Cached entry or null if not found/expired
     */
    async get(key) {
        const node = this.cache.get(key);
        if (!node) {
            this.misses++;
            return null;
        }
        // Check if expired
        if (Date.now() > node.entry.expiresAt) {
            await this.delete(key);
            this.misses++;
            return null;
        }
        // Move to front (most recently used)
        this.moveToFront(node);
        this.hits++;
        return node.entry;
    }
    /**
     * Set cache entry
     *
     * @param {string} key - Cache key
     * @param {CacheEntry} entry - Cache entry
     * @returns {Promise<void>}
     */
    async set(key, entry) {
        // Update existing entry
        const existingNode = this.cache.get(key);
        if (existingNode) {
            existingNode.entry = entry;
            this.moveToFront(existingNode);
            return;
        }
        // Create new node
        const newNode = {
            key,
            entry,
            prev: null,
            next: null,
        };
        // Add to front
        this.addToFront(newNode);
        this.cache.set(key, newNode);
        // Evict LRU if over capacity
        if (this.cache.size > this.maxSize) {
            await this.evictLRU();
        }
    }
    /**
     * Delete cache entry
     *
     * @param {string} key - Cache key
     * @returns {Promise<boolean>} True if deleted, false if not found
     */
    async delete(key) {
        const node = this.cache.get(key);
        if (!node) {
            return false;
        }
        this.removeNode(node);
        this.cache.delete(key);
        return true;
    }
    /**
     * Clear all cache entries
     *
     * @returns {Promise<void>}
     */
    async clear() {
        this.cache.clear();
        this.head = null;
        this.tail = null;
        this.hits = 0;
        this.misses = 0;
        this.evictions = 0;
    }
    /**
     * Check if key exists in cache
     *
     * @param {string} key - Cache key
     * @returns {Promise<boolean>} True if exists and not expired
     */
    async has(key) {
        const entry = await this.get(key);
        return entry !== null;
    }
    /**
     * Get all keys in cache
     *
     * @returns {Promise<string[]>} Array of cache keys
     */
    async keys() {
        return Array.from(this.cache.keys());
    }
    /**
     * Get cache statistics
     *
     * @returns {Promise<CacheStats>} Cache statistics
     */
    async stats() {
        const total = this.hits + this.misses;
        const hitRate = total > 0 ? this.hits / total : 0;
        // Estimate size (rough approximation)
        let sizeBytes = 0;
        for (const node of this.cache.values()) {
            sizeBytes += JSON.stringify(node.entry.data).length;
        }
        return {
            entries: this.cache.size,
            sizeBytes,
            hits: this.hits,
            misses: this.misses,
            hitRate,
            evictions: this.evictions,
        };
    }
    /**
     * Invalidate entries by tags
     *
     * @param {string[]} tags - Tags to invalidate
     * @returns {Promise<number>} Number of entries invalidated
     */
    async invalidateByTags(tags) {
        let count = 0;
        const keysToDelete = [];
        for (const [key, node] of this.cache.entries()) {
            const entryTags = node.entry.tags ?? [];
            if (tags.some(tag => entryTags.includes(tag))) {
                keysToDelete.push(key);
            }
        }
        for (const key of keysToDelete) {
            if (await this.delete(key)) {
                count++;
            }
        }
        return count;
    }
    /**
     * Invalidate entries by source
     *
     * @param {HealthSource} source - Source to invalidate
     * @returns {Promise<number>} Number of entries invalidated
     */
    async invalidateBySource(source) {
        let count = 0;
        const keysToDelete = [];
        for (const [key, _node] of this.cache.entries()) {
            // Parse key to get source
            const parsedKey = (0, cache_provider_1.parseCacheKey)(key);
            if (parsedKey && parsedKey.source === source) {
                keysToDelete.push(key);
            }
        }
        for (const key of keysToDelete) {
            if (await this.delete(key)) {
                count++;
            }
        }
        return count;
    }
    /**
     * Cleanup expired entries
     *
     * @returns {Promise<number>} Number of entries cleaned up
     */
    async cleanup() {
        let count = 0;
        const now = Date.now();
        const keysToDelete = [];
        for (const [key, node] of this.cache.entries()) {
            if (now > node.entry.expiresAt) {
                keysToDelete.push(key);
            }
        }
        for (const key of keysToDelete) {
            if (await this.delete(key)) {
                count++;
            }
        }
        return count;
    }
    /**
     * Move node to front of LRU list (most recently used)
     *
     * @param {LRUNode} node - Node to move
     * @private
     */
    moveToFront(node) {
        if (node === this.head) {
            return;
        }
        this.removeNode(node);
        this.addToFront(node);
    }
    /**
     * Add node to front of LRU list
     *
     * @param {LRUNode} node - Node to add
     * @private
     */
    addToFront(node) {
        node.next = this.head;
        node.prev = null;
        if (this.head) {
            this.head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
            this.tail = node;
        }
    }
    /**
     * Remove node from LRU list
     *
     * @param {LRUNode} node - Node to remove
     * @private
     */
    removeNode(node) {
        if (node.prev) {
            node.prev.next = node.next;
        }
        else {
            this.head = node.next;
        }
        if (node.next) {
            node.next.prev = node.prev;
        }
        else {
            this.tail = node.prev;
        }
        node.prev = null;
        node.next = null;
    }
    /**
     * Evict least recently used entry
     *
     * @returns {Promise<void>}
     * @private
     */
    async evictLRU() {
        if (!this.tail) {
            return;
        }
        const lruKey = this.tail.key;
        await this.delete(lruKey);
        this.evictions++;
    }
}
exports.MemoryCacheProvider = MemoryCacheProvider;
//# sourceMappingURL=memory-cache.js.map