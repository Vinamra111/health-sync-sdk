/**
 * In-Memory Cache Provider
 *
 * Fast, session-only cache using LRU eviction strategy.
 * Implements the ICacheProvider interface with in-memory Map storage.
 *
 * @module cache/memory-cache
 */
import { HealthSource } from '../models/unified-data';
import { ICacheProvider, CacheEntry, CacheStats } from './cache-provider';
/**
 * In-Memory Cache Provider with LRU Eviction
 *
 * @class MemoryCacheProvider
 * @implements {ICacheProvider}
 */
export declare class MemoryCacheProvider implements ICacheProvider {
    private cache;
    private head;
    private tail;
    private maxSize;
    private hits;
    private misses;
    private evictions;
    /**
     * Create memory cache provider
     *
     * @param {number} [maxSize=1000] - Maximum number of entries
     */
    constructor(maxSize?: number);
    /**
     * Get cached data by key
     *
     * @param {string} key - Cache key
     * @returns {Promise<CacheEntry | null>} Cached entry or null if not found/expired
     */
    get(key: string): Promise<CacheEntry | null>;
    /**
     * Set cache entry
     *
     * @param {string} key - Cache key
     * @param {CacheEntry} entry - Cache entry
     * @returns {Promise<void>}
     */
    set(key: string, entry: CacheEntry): Promise<void>;
    /**
     * Delete cache entry
     *
     * @param {string} key - Cache key
     * @returns {Promise<boolean>} True if deleted, false if not found
     */
    delete(key: string): Promise<boolean>;
    /**
     * Clear all cache entries
     *
     * @returns {Promise<void>}
     */
    clear(): Promise<void>;
    /**
     * Check if key exists in cache
     *
     * @param {string} key - Cache key
     * @returns {Promise<boolean>} True if exists and not expired
     */
    has(key: string): Promise<boolean>;
    /**
     * Get all keys in cache
     *
     * @returns {Promise<string[]>} Array of cache keys
     */
    keys(): Promise<string[]>;
    /**
     * Get cache statistics
     *
     * @returns {Promise<CacheStats>} Cache statistics
     */
    stats(): Promise<CacheStats>;
    /**
     * Invalidate entries by tags
     *
     * @param {string[]} tags - Tags to invalidate
     * @returns {Promise<number>} Number of entries invalidated
     */
    invalidateByTags(tags: string[]): Promise<number>;
    /**
     * Invalidate entries by source
     *
     * @param {HealthSource} source - Source to invalidate
     * @returns {Promise<number>} Number of entries invalidated
     */
    invalidateBySource(source: HealthSource): Promise<number>;
    /**
     * Cleanup expired entries
     *
     * @returns {Promise<number>} Number of entries cleaned up
     */
    cleanup(): Promise<number>;
    /**
     * Move node to front of LRU list (most recently used)
     *
     * @param {LRUNode} node - Node to move
     * @private
     */
    private moveToFront;
    /**
     * Add node to front of LRU list
     *
     * @param {LRUNode} node - Node to add
     * @private
     */
    private addToFront;
    /**
     * Remove node from LRU list
     *
     * @param {LRUNode} node - Node to remove
     * @private
     */
    private removeNode;
    /**
     * Evict least recently used entry
     *
     * @returns {Promise<void>}
     * @private
     */
    private evictLRU;
}
//# sourceMappingURL=memory-cache.d.ts.map