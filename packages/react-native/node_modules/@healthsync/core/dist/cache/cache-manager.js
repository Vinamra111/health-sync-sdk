"use strict";
/**
 * Cache Manager
 *
 * High-level cache orchestration with TTL, invalidation strategies,
 * and multi-layer caching support.
 *
 * @module cache/cache-manager
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheManager = void 0;
const unified_data_1 = require("../models/unified-data");
const config_1 = require("../types/config");
const cache_provider_1 = require("./cache-provider");
const memory_cache_1 = require("./memory-cache");
/**
 * Default cache configuration
 */
const DEFAULT_CONFIG = {
    enabled: true,
    defaultTTL: 30 * 60 * 1000, // 30 minutes
    ttlByDataType: {
        [unified_data_1.DataType.STEPS]: 60 * 60 * 1000, // 1 hour
        [unified_data_1.DataType.HEART_RATE]: 30 * 60 * 1000, // 30 minutes
        [unified_data_1.DataType.SLEEP]: 24 * 60 * 60 * 1000, // 24 hours
        [unified_data_1.DataType.WEIGHT]: 24 * 60 * 60 * 1000, // 24 hours
    },
    maxMemoryEntries: 1000,
    autoCleanup: true,
    cleanupInterval: 5 * 60 * 1000, // 5 minutes
};
/**
 * Cache Manager
 *
 * Manages multi-layer caching with automatic TTL and invalidation.
 *
 * @class CacheManager
 */
class CacheManager {
    /**
     * Create cache manager
     *
     * @param {CacheManagerConfig} [config] - Cache configuration
     */
    constructor(config = {}) {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "memoryCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "externalCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cleanupTimer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.config = {
            ...DEFAULT_CONFIG,
            ...config,
            ttlByDataType: {
                ...DEFAULT_CONFIG.ttlByDataType,
                ...config.ttlByDataType,
            },
        };
        this.logger = config.logger;
        this.memoryCache = new memory_cache_1.MemoryCacheProvider(this.config.maxMemoryEntries);
        this.externalCache = config.externalProvider;
        if (this.config.autoCleanup) {
            this.startAutoCleanup();
        }
    }
    /**
     * Get cached data
     *
     * Checks memory cache first (L1), then external cache (L2) if available.
     *
     * @param {CacheKey} key - Cache key
     * @returns {Promise<AnyHealthData[] | null>} Cached data or null
     */
    async get(key) {
        if (!this.config.enabled) {
            return null;
        }
        const cacheKey = (0, cache_provider_1.generateCacheKey)(key);
        // Try memory cache first (L1)
        let entry = await this.memoryCache.get(cacheKey);
        if (entry) {
            this.log(config_1.LogLevel.DEBUG, `Cache hit (L1): ${cacheKey}`);
            return entry.data;
        }
        // Try external cache (L2)
        if (this.externalCache) {
            entry = await this.externalCache.get(cacheKey);
            if (entry) {
                this.log(config_1.LogLevel.DEBUG, `Cache hit (L2): ${cacheKey}`);
                // Promote to memory cache
                await this.memoryCache.set(cacheKey, entry);
                return entry.data;
            }
        }
        this.log(config_1.LogLevel.DEBUG, `Cache miss: ${cacheKey}`);
        return null;
    }
    /**
     * Set cached data
     *
     * Stores in both memory cache (L1) and external cache (L2) if available.
     *
     * @param {CacheKey} key - Cache key
     * @param {AnyHealthData[]} data - Data to cache
     * @param {number} [ttl] - TTL in milliseconds (overrides default)
     * @param {string[]} [tags] - Tags for invalidation
     * @returns {Promise<void>}
     */
    async set(key, data, ttl, tags) {
        if (!this.config.enabled) {
            return;
        }
        const cacheKey = (0, cache_provider_1.generateCacheKey)(key);
        const effectiveTTL = this.getTTL(key.dataType, ttl);
        const now = Date.now();
        const entry = {
            data,
            cachedAt: now,
            expiresAt: now + effectiveTTL,
            source: key.source,
            dataType: key.dataType,
        };
        if (tags !== undefined) {
            entry.tags = tags;
        }
        // Store in memory cache (L1)
        await this.memoryCache.set(cacheKey, entry);
        // Store in external cache (L2)
        if (this.externalCache) {
            await this.externalCache.set(cacheKey, entry);
        }
        this.log(config_1.LogLevel.DEBUG, `Cached data: ${cacheKey} (TTL: ${effectiveTTL}ms)`);
    }
    /**
     * Delete cached data
     *
     * @param {CacheKey} key - Cache key
     * @returns {Promise<boolean>} True if deleted from any cache
     */
    async delete(key) {
        const cacheKey = (0, cache_provider_1.generateCacheKey)(key);
        const deleted1 = await this.memoryCache.delete(cacheKey);
        const deleted2 = this.externalCache
            ? await this.externalCache.delete(cacheKey)
            : false;
        if (deleted1 || deleted2) {
            this.log(config_1.LogLevel.DEBUG, `Deleted from cache: ${cacheKey}`);
        }
        return deleted1 || deleted2;
    }
    /**
     * Clear all caches
     *
     * @returns {Promise<void>}
     */
    async clear() {
        await this.memoryCache.clear();
        if (this.externalCache) {
            await this.externalCache.clear();
        }
        this.log(config_1.LogLevel.INFO, 'Cleared all caches');
    }
    /**
     * Invalidate cache entries by source
     *
     * @param {HealthSource} source - Source to invalidate
     * @returns {Promise<number>} Number of entries invalidated
     */
    async invalidateBySource(source) {
        let count = 0;
        count += await this.memoryCache.invalidateBySource(source);
        if (this.externalCache) {
            count += await this.externalCache.invalidateBySource(source);
        }
        this.log(config_1.LogLevel.INFO, `Invalidated ${count} entries for source: ${source}`);
        return count;
    }
    /**
     * Invalidate cache entries by data type
     *
     * @param {DataType} dataType - Data type to invalidate
     * @returns {Promise<number>} Number of entries invalidated
     */
    async invalidateByDataType(dataType) {
        const tags = [`dataType:${dataType}`];
        let count = 0;
        count += await this.memoryCache.invalidateByTags(tags);
        if (this.externalCache) {
            count += await this.externalCache.invalidateByTags(tags);
        }
        this.log(config_1.LogLevel.INFO, `Invalidated ${count} entries for data type: ${dataType}`);
        return count;
    }
    /**
     * Invalidate cache entries by tags
     *
     * @param {string[]} tags - Tags to invalidate
     * @returns {Promise<number>} Number of entries invalidated
     */
    async invalidateByTags(tags) {
        let count = 0;
        count += await this.memoryCache.invalidateByTags(tags);
        if (this.externalCache) {
            count += await this.externalCache.invalidateByTags(tags);
        }
        this.log(config_1.LogLevel.INFO, `Invalidated ${count} entries by tags: ${tags.join(', ')}`);
        return count;
    }
    /**
     * Cleanup expired entries
     *
     * @returns {Promise<number>} Number of entries cleaned up
     */
    async cleanup() {
        let count = 0;
        count += await this.memoryCache.cleanup();
        if (this.externalCache) {
            count += await this.externalCache.cleanup();
        }
        if (count > 0) {
            this.log(config_1.LogLevel.DEBUG, `Cleaned up ${count} expired cache entries`);
        }
        return count;
    }
    /**
     * Get cache statistics
     *
     * @returns {Promise<{ memory: CacheStats; external?: CacheStats }>} Cache stats
     */
    async stats() {
        const memory = await this.memoryCache.stats();
        const result = { memory };
        if (this.externalCache) {
            result.external = await this.externalCache.stats();
        }
        return result;
    }
    /**
     * Dispose cache manager
     *
     * Stops cleanup timer and clears caches.
     *
     * @returns {Promise<void>}
     */
    async dispose() {
        this.stopAutoCleanup();
        await this.clear();
        this.log(config_1.LogLevel.INFO, 'Cache manager disposed');
    }
    /**
     * Get TTL for data type
     *
     * @param {DataType} dataType - Data type
     * @param {number} [override] - Override TTL
     * @returns {number} TTL in milliseconds
     * @private
     */
    getTTL(dataType, override) {
        if (override !== undefined) {
            return override;
        }
        return this.config.ttlByDataType[dataType] ?? this.config.defaultTTL;
    }
    /**
     * Start automatic cleanup
     *
     * @private
     */
    startAutoCleanup() {
        this.cleanupTimer = setInterval(() => {
            this.cleanup().catch(err => {
                this.log(config_1.LogLevel.ERROR, `Auto cleanup error: ${err}`);
            });
        }, this.config.cleanupInterval);
        // Prevent timer from keeping process alive
        if (this.cleanupTimer.unref) {
            this.cleanupTimer.unref();
        }
    }
    /**
     * Stop automatic cleanup
     *
     * @private
     */
    stopAutoCleanup() {
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
            this.cleanupTimer = undefined;
        }
    }
    /**
     * Log message
     *
     * @param {LogLevel} level - Log level
     * @param {string} message - Log message
     * @private
     */
    log(level, message) {
        if (!this.logger) {
            return;
        }
        const msg = `[CacheManager] ${message}`;
        switch (level) {
            case config_1.LogLevel.DEBUG:
                this.logger.debug(msg);
                break;
            case config_1.LogLevel.INFO:
                this.logger.info(msg);
                break;
            case config_1.LogLevel.WARN:
                this.logger.warn(msg);
                break;
            case config_1.LogLevel.ERROR:
                this.logger.error(msg);
                break;
        }
    }
}
exports.CacheManager = CacheManager;
//# sourceMappingURL=cache-manager.js.map