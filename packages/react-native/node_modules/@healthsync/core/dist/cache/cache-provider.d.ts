/**
 * Cache Provider Interface
 *
 * Abstract interface for cache storage backends.
 * Implementations can use different storage mechanisms (memory, SQLite, IndexedDB, etc.)
 *
 * @module cache/cache-provider
 */
import { DataType, HealthSource } from '../models/unified-data';
/**
 * Cache entry with metadata
 *
 * @interface CacheEntry
 * @template T
 */
export interface CacheEntry<T = unknown> {
    /** Cached data */
    data: T;
    /** When the entry was cached */
    cachedAt: number;
    /** When the entry expires (timestamp) */
    expiresAt: number;
    /** Source of the data */
    source: HealthSource;
    /** Type of data */
    dataType: DataType;
    /** Optional tags for invalidation */
    tags?: string[];
}
/**
 * Cache key structure
 *
 * @interface CacheKey
 */
export interface CacheKey {
    /** Data source */
    source: HealthSource;
    /** Type of health data */
    dataType: DataType;
    /** Start date for the query */
    startDate: string;
    /** End date for the query */
    endDate: string;
    /** Additional query parameters */
    params?: Record<string, unknown>;
}
/**
 * Cache statistics
 *
 * @interface CacheStats
 */
export interface CacheStats {
    /** Total number of entries */
    entries: number;
    /** Total size in bytes (approximate) */
    sizeBytes: number;
    /** Cache hits */
    hits: number;
    /** Cache misses */
    misses: number;
    /** Hit rate (0-1) */
    hitRate: number;
    /** Evictions count */
    evictions: number;
}
/**
 * Cache provider interface
 *
 * Defines the contract for cache storage backends.
 *
 * @interface ICacheProvider
 */
export interface ICacheProvider {
    /**
     * Get cached data by key
     *
     * @param {string} key - Cache key
     * @returns {Promise<CacheEntry | null>} Cached entry or null if not found/expired
     */
    get(key: string): Promise<CacheEntry | null>;
    /**
     * Set cache entry
     *
     * @param {string} key - Cache key
     * @param {CacheEntry} entry - Cache entry
     * @returns {Promise<void>}
     */
    set(key: string, entry: CacheEntry): Promise<void>;
    /**
     * Delete cache entry
     *
     * @param {string} key - Cache key
     * @returns {Promise<boolean>} True if deleted, false if not found
     */
    delete(key: string): Promise<boolean>;
    /**
     * Clear all cache entries
     *
     * @returns {Promise<void>}
     */
    clear(): Promise<void>;
    /**
     * Check if key exists in cache
     *
     * @param {string} key - Cache key
     * @returns {Promise<boolean>} True if exists and not expired
     */
    has(key: string): Promise<boolean>;
    /**
     * Get all keys in cache
     *
     * @returns {Promise<string[]>} Array of cache keys
     */
    keys(): Promise<string[]>;
    /**
     * Get cache statistics
     *
     * @returns {Promise<CacheStats>} Cache statistics
     */
    stats(): Promise<CacheStats>;
    /**
     * Invalidate entries by tags
     *
     * @param {string[]} tags - Tags to invalidate
     * @returns {Promise<number>} Number of entries invalidated
     */
    invalidateByTags(tags: string[]): Promise<number>;
    /**
     * Invalidate entries by source
     *
     * @param {HealthSource} source - Source to invalidate
     * @returns {Promise<number>} Number of entries invalidated
     */
    invalidateBySource(source: HealthSource): Promise<number>;
    /**
     * Cleanup expired entries
     *
     * @returns {Promise<number>} Number of entries cleaned up
     */
    cleanup(): Promise<number>;
}
/**
 * Generate cache key from CacheKey structure
 *
 * @param {CacheKey} key - Cache key structure
 * @returns {string} Serialized cache key
 */
export declare function generateCacheKey(key: CacheKey): string;
/**
 * Parse cache key string back to CacheKey structure
 *
 * @param {string} keyString - Serialized cache key
 * @returns {CacheKey | null} Parsed cache key or null if invalid
 */
export declare function parseCacheKey(keyString: string): CacheKey | null;
//# sourceMappingURL=cache-provider.d.ts.map