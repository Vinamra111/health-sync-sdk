"use strict";
/**
 * Plugin Registry
 *
 * This module manages the registration, lifecycle, and retrieval of health data plugins.
 *
 * @module plugins/plugin-registry
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginRegistry = void 0;
const unified_data_1 = require("../models/unified-data");
const plugin_interface_1 = require("./plugin-interface");
const config_1 = require("../types/config");
/**
 * Plugin Registry
 *
 * Manages the lifecycle and organization of health data plugins.
 *
 * @class PluginRegistry
 */
class PluginRegistry {
    constructor() {
        /** Map of plugin ID to plugin entry */
        Object.defineProperty(this, "plugins", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        /** Map of health source to plugin ID */
        Object.defineProperty(this, "sourceToPlugin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    /**
     * Register a new plugin
     *
     * @param {IHealthDataPlugin} plugin - The plugin to register
     * @throws {PluginError} If plugin with same ID already exists
     * @returns {void}
     */
    register(plugin) {
        if (this.plugins.has(plugin.id)) {
            throw new config_1.PluginError(`Plugin with ID '${plugin.id}' is already registered`, plugin.id, 400);
        }
        // Validate plugin implements required properties
        if (!plugin.id || !plugin.name || !plugin.version) {
            throw new config_1.ConfigurationError('Plugin must have id, name, and version properties', { pluginId: plugin.id });
        }
        const entry = {
            plugin,
            initialized: false,
            connectionStatus: plugin_interface_1.ConnectionStatus.DISCONNECTED,
            registeredAt: new Date().toISOString(),
        };
        this.plugins.set(plugin.id, entry);
        // Map health source to plugin (assuming plugin ID matches source for now)
        // This can be enhanced to support multiple sources per plugin
        const source = this.pluginIdToHealthSource(plugin.id);
        if (source) {
            this.sourceToPlugin.set(source, plugin.id);
        }
    }
    /**
     * Unregister a plugin
     *
     * @param {string} pluginId - ID of the plugin to unregister
     * @returns {Promise<void>}
     * @throws {PluginError} If plugin is not found
     */
    async unregister(pluginId) {
        const entry = this.plugins.get(pluginId);
        if (!entry) {
            throw new config_1.PluginError(`Plugin '${pluginId}' not found`, pluginId, 404);
        }
        // Dispose plugin if initialized
        if (entry.initialized) {
            try {
                await entry.plugin.dispose();
            }
            catch (error) {
                // Log error but continue with unregistration
                console.error(`Error disposing plugin '${pluginId}':`, error);
            }
        }
        // Remove from maps
        this.plugins.delete(pluginId);
        // Remove source mapping
        for (const [source, id] of this.sourceToPlugin.entries()) {
            if (id === pluginId) {
                this.sourceToPlugin.delete(source);
            }
        }
    }
    /**
     * Get a plugin by ID
     *
     * @param {string} pluginId - ID of the plugin
     * @returns {IHealthDataPlugin | undefined} The plugin instance or undefined
     */
    getPlugin(pluginId) {
        return this.plugins.get(pluginId)?.plugin;
    }
    /**
     * Get a plugin by health source
     *
     * @param {HealthSource} source - Health source
     * @returns {IHealthDataPlugin | undefined} The plugin instance or undefined
     */
    getPluginBySource(source) {
        const pluginId = this.sourceToPlugin.get(source);
        if (!pluginId) {
            return undefined;
        }
        return this.getPlugin(pluginId);
    }
    /**
     * Get all registered plugins
     *
     * @returns {IHealthDataPlugin[]} Array of all plugins
     */
    getAllPlugins() {
        return Array.from(this.plugins.values()).map((entry) => entry.plugin);
    }
    /**
     * Get all initialized plugins
     *
     * @returns {IHealthDataPlugin[]} Array of initialized plugins
     */
    getInitializedPlugins() {
        return Array.from(this.plugins.values())
            .filter((entry) => entry.initialized)
            .map((entry) => entry.plugin);
    }
    /**
     * Get all connected plugins
     *
     * @returns {IHealthDataPlugin[]} Array of connected plugins
     */
    getConnectedPlugins() {
        return Array.from(this.plugins.values())
            .filter((entry) => entry.connectionStatus === plugin_interface_1.ConnectionStatus.CONNECTED)
            .map((entry) => entry.plugin);
    }
    /**
     * Get plugin info for all plugins
     *
     * @returns {Promise<PluginInfo[]>} Array of plugin info
     */
    async getPluginInfo() {
        const plugins = this.getAllPlugins();
        const infoPromises = plugins.map(async (plugin) => {
            if (plugin.getInfo) {
                return plugin.getInfo();
            }
            // Fallback to basic info
            return {
                id: plugin.id,
                name: plugin.name,
                version: plugin.version,
                supportedDataTypes: plugin.supportedDataTypes,
                requiresAuthentication: plugin.requiresAuthentication,
                isCloudBased: plugin.isCloudBased,
            };
        });
        return Promise.all(infoPromises);
    }
    /**
     * Check if a plugin is initialized
     *
     * @param {string} pluginId - ID of the plugin
     * @returns {boolean} True if plugin is initialized
     */
    isInitialized(pluginId) {
        return this.plugins.get(pluginId)?.initialized ?? false;
    }
    /**
     * Mark a plugin as initialized
     *
     * @param {string} pluginId - ID of the plugin
     * @returns {void}
     * @throws {PluginError} If plugin is not found
     */
    markInitialized(pluginId) {
        const entry = this.plugins.get(pluginId);
        if (!entry) {
            throw new config_1.PluginError(`Plugin '${pluginId}' not found`, pluginId, 404);
        }
        entry.initialized = true;
        entry.lastInitializedAt = new Date().toISOString();
    }
    /**
     * Update plugin connection status
     *
     * @param {string} pluginId - ID of the plugin
     * @param {ConnectionStatus} status - New connection status
     * @returns {void}
     * @throws {PluginError} If plugin is not found
     */
    updateConnectionStatus(pluginId, status) {
        const entry = this.plugins.get(pluginId);
        if (!entry) {
            throw new config_1.PluginError(`Plugin '${pluginId}' not found`, pluginId, 404);
        }
        entry.connectionStatus = status;
    }
    /**
     * Get plugin connection status
     *
     * @param {string} pluginId - ID of the plugin
     * @returns {ConnectionStatus} Connection status
     * @throws {PluginError} If plugin is not found
     */
    getConnectionStatus(pluginId) {
        const entry = this.plugins.get(pluginId);
        if (!entry) {
            throw new config_1.PluginError(`Plugin '${pluginId}' not found`, pluginId, 404);
        }
        return entry.connectionStatus;
    }
    /**
     * Get the number of registered plugins
     *
     * @returns {number} Number of plugins
     */
    count() {
        return this.plugins.size;
    }
    /**
     * Clear all plugins
     *
     * Disposes all plugins and clears the registry.
     *
     * @returns {Promise<void>}
     */
    async clear() {
        const disposePromises = Array.from(this.plugins.values()).map(async (entry) => {
            if (entry.initialized) {
                try {
                    await entry.plugin.dispose();
                }
                catch (error) {
                    console.error(`Error disposing plugin '${entry.plugin.id}':`, error);
                }
            }
        });
        await Promise.all(disposePromises);
        this.plugins.clear();
        this.sourceToPlugin.clear();
    }
    /**
     * Convert plugin ID to health source
     *
     * This is a helper method that maps plugin IDs to health sources.
     * Can be extended to support custom mappings.
     *
     * @param {string} pluginId - Plugin ID
     * @returns {HealthSource | undefined} Corresponding health source
     * @private
     */
    pluginIdToHealthSource(pluginId) {
        const mapping = {
            'health-connect': unified_data_1.HealthSource.HEALTH_CONNECT,
            'health_connect': unified_data_1.HealthSource.HEALTH_CONNECT,
            'apple-health': unified_data_1.HealthSource.APPLE_HEALTH,
            'apple_health': unified_data_1.HealthSource.APPLE_HEALTH,
            'healthkit': unified_data_1.HealthSource.APPLE_HEALTH,
            fitbit: unified_data_1.HealthSource.FITBIT,
            garmin: unified_data_1.HealthSource.GARMIN,
            oura: unified_data_1.HealthSource.OURA,
            whoop: unified_data_1.HealthSource.WHOOP,
            strava: unified_data_1.HealthSource.STRAVA,
            myfitnesspal: unified_data_1.HealthSource.MYFITNESSPAL,
        };
        return mapping[pluginId.toLowerCase()];
    }
}
exports.PluginRegistry = PluginRegistry;
//# sourceMappingURL=plugin-registry.js.map